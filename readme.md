Это расширение для VS Code позволяет синхронизировать ваш локальный Git-репозиторий с Google Drive. Оно не создает полноценный git remote, а использует Google Drive как "транспорт" для обмена данными с помощью файлов-бандлов (.bundle).

Это удобно для:

Резервного копирования: хранения копии репозитория в облаке.
Работы оффлайн: обмена изменениями между компьютерами без доступа к центральному Git-серверу (вроде GitHub/GitLab).
Простого обмена кодом: когда нужно передать всю историю проекта в одном файле.
Принцип работы
Расширение работает в несколько шагов:

Настройка: Сначала вы должны указать расширению ваш файл client_secret.json от Google Cloud и пройти аутентификацию. Расширение надежно сохранит полученные токены для будущих сессий.
Выгрузка изменений (Push):
Когда вы запускаете sync или initialUpload, расширение создает "бандл" — специальный файл Git, содержащий всю историю коммитов для вашей текущей ветки (git bundle create ...).
Оно находит на вашем Google Drive папку с именем .gdrive-git/<имя_вашего_проекта>/. Если папки нет, оно её создаёт.
В эту папку загружается (или обновляется) файл бандла, названный по имени вашей ветки (например, main.bundle).
Загрузка изменений (Pull):
Когда вы запускаете sync, расширение сначала пытается скачать изменения.
Оно ищет на Google Drive бандл-файл для вашей текущей ветки.
Если файл найден, оно скачивает его и выполняет команду git pull из этого локального файла. Git автоматически "подтягивает" недостающие коммиты и пытается слить их с вашей текущей работой.
Если возникают конфликты слияния, расширение сообщает об этом, и вы можете разрешить их стандартными средствами Git.

Для просмотра документации из docs можно воспользоваться расширением https://github.com/adva-cg/drakonwidget-for-vscode

А мы можем бандлы готовить после каждого коммита? И не заменять их в гугл драйв. Т.е. схема такая, перед коммитом в гит мы проверяем наличие чужих бандлов (или по имени компа и метке времени с предыдущей проверки, или по хешу своих коммитов, не знаю как лучше), а после коммита, посылаем в гугл драйв свой разностный бандл?


Gemini
Thinking
stat_minus_1
Это отличная и очень проницательная идея! Вы, по сути, описываете, как работают настоящие распределенные системы контроля версий (такие как сам Git). Вместо того чтобы заменять один большой файл (монолитное состояние), мы обмениваемся "событиями" (коммитами) и собираем из них общую историю.

Это абсолютно возможно реализовать, и это сделает процесс более надежным и похожим на работу с настоящим удаленным репозиторием.

Однако это значительно усложняет логику по сравнению с текущей реализацией. Нам нужно будет:

Использовать Git-хуки (в частности, post-commit) для автоматической отправки.
Тщательно управлять состоянием — знать, какой коммит был последним отправленным, чтобы создавать разностный (дифференциальный) бандл.
Разработать надежный механизм получения и применения множества "чужих" бандлов.
Давайте разберем, как это могло бы работать.

Новая схема работы с разностными бандлами
Хранение на Google Drive
Вместо одного файла main.bundle мы будем хранить каждый инкремент в отдельном файле в папке objects (или bundles). Имя файла будет соответствовать хешу коммита, который он добавляет.

.../.gdrive-git/my-project/bundles/
a1b2c3d4.bundle
e5f6g7h8.bundle
i9j0k1l2.bundle
⬆️ Отправка изменений (после каждого коммита)
Этот процесс будет запускаться автоматически хуком post-commit.

Сразу после git commit:
Хук запускает скрипт расширения.
Скрипт получает хеш только что созданного коммита (HEAD).
Определение базы для бандла:
Расширение хранит в workspaceState хеш последнего успешно отправленного коммита (lastPushedHash).
Если lastPushedHash есть, он будет использован как база для создания разностного бандла. Если его нет (первый пуш), бандл будет содержать всю историю до HEAD.
Создание разностного бандла:
Выполняется команда: git bundle create <хеш_HEAD>.bundle HEAD..<lastPushedHash>
Эта команда создает бандл, содержащий только те объекты, которые доступны из HEAD, но не из lastPushedHash.
Отправка на Google Drive:
Новый файл <хеш_HEAD>.bundle загружается в папку bundles на Google Drive.
Обновление состояния:
После успешной загрузки lastPushedHash в workspaceState обновляется на хеш HEAD.
⬇️ Получение изменений (команда sync)
Это будет ручная команда, которую нужно выполнять перед началом работы или перед коммитом, чтобы получить чужие изменения.

Запрос списка бандлов:
Расширение запрашивает у Google Drive список всех файлов в папке bundles.
Определение недостающих коммитов:
Расширение сравнивает список хешей из имен файлов-бандлов со списком коммитов, которые уже есть в локальном репозитории (git log --pretty=%H).
Все бандлы, хешей которых нет локально, считаются "новыми".
Скачивание и применение:
Расширение скачивает все "новые" бандлы во временную папку.
Затем оно последовательно применяет их с помощью git pull <путь_к_бандлу>. Git сам разберется с зависимостями и объединит истории.
Слияние (Merge/Rebase):
После применения всех бандлов, если ваша текущая работа расходится с полученной историей, git pull создаст коммит слияния (merge commit) или предложит вам разрешить конфликты, как при обычной работе с Git.
Ответ на ваш вопрос о "проверке перед коммитом"
...перед коммитом в гит мы проверяем наличие чужих бандлов...

Это плохая практика с точки зрения UX. git commit должна быть быстрой локальной операцией. Добавление в нее сетевых запросов (проверка Google Drive) сделает ее медленной и ненадежной.

Правильный рабочий процесс будет таким:

Перед началом работы: Выполняете команду sync в VS Code, чтобы скачать все последние изменения от других.
Работаете: Пишете код, делаете локальные коммиты.
После каждого коммита: Хук post-commit автоматически и незаметно для вас отправляет маленький разностный бандл на Google Drive.
Итог:

Эта схема гораздо мощнее и правильнее с точки зрения идеологии Git. Она превращает Google Drive в подобие децентрализованного Git-сервера. Но она требует более сложной реализации и аккуратной работы с состоянием и Git-хуками.

Если вас устраивает такая усложненная, но более мощная схема, я могу приступить к переделке кода.

 полностью переписал код расширения, чтобы он работал по новой, более надежной схеме с разностными бандлами.

Что изменилось:
Push (Выгрузка):

Теперь команда pushCommits определяет, какие коммиты являются новыми с момента последней отправки.
Она создает маленький разностный бандл, содержащий только эти новые коммиты.
Каждый бандл загружается на Google Drive как отдельный файл с именем, соответствующим хешу последнего коммита в нем (например, a1b2c3d4.bundle).
Pull (Загрузка):

Команда pullCommits теперь скачивает с Google Drive только те бандлы, которых у вас еще нет локально.
Она использует git fetch для безопасного добавления коммитов из этих бандлов в ваш локальный репозиторий. Это не затрагивает вашу рабочую директорию, но обновляет "удаленные" ветки.
После fetch вы можете использовать стандартные команды git merge или git rebase, чтобы объединить полученные изменения со своей работой.
Git Hooks (Автоматизация):

Появилась новая команда installGitHooks. Она создает в вашем репозитории (.git/hooks/) файл post-commit.
Этот хук будет автоматически запускать команду sync каждый раз, когда вы делаете git commit. Это означает, что ваши коммиты будут отправляться на Google Drive в фоновом режиме, без вашего участия.
Как теперь этим пользоваться:
Первоначальная настройка:
Как и раньше, выполните команды "Установить учетные данные Google" и "Аутентификация с Google".
Установка хука (ОЧЕНЬ ВАЖНО!):
Один раз для вашего проекта выполните команду "Install Git Hooks". Это включит автоматическую отправку коммитов.
Рабочий процесс:
Перед началом работы: Выполните команду "Sync with Google Drive", чтобы получить все последние изменения от других.
Работайте как обычно: Пишите код и делайте git commit. Расширение само отправит ваши коммиты на Google Drive после каждого из них.
Чтобы обновить историю: Периодически запускайте "Sync with Google Drive", чтобы подтянуть чужие коммиты, которые могли появиться, пока вы работали.
Эта версия намного ближе к тому, как работает настоящий Git, и должна быть значительно надежнее и удобнее в долгосрочной перспективе.